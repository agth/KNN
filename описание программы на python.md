Разберём подробно как работает программа на python

1. Для програмной реализации испоользуется стандартная библиотека scikit-learn.
  Можно написать не используя, для этого нужно самому задать выборку и алгоритм который будет с ней работать.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn import neighbors, datasets

2. объявляется глобалльная переменная и присваивается ей значение. Эта переменная хранит значение K - количество ближайших 
  соседей которое будет искаться. 
  n_neighbors = 15

3. Объявляем переменную iris и присваиваем ей значение стандартной выборки iris из библиотеки, которую вызвали в начале. В этой строке
  from sklearn import neighbors, datasets
    Выборка iris представляет из себя таблицу 150 строк на 4 столбца. 
  iris = datasets.load_iris() 

4. Так как нам нужна выборка точек на плоскости, то нам нужна таблица 150 строк на 2 столбца, номер строки - номер точки, 
  первый столбец хранит координату точек по горизонтали, а второй по вертикали. Объявим переменную присвоим ей матрицу с двумя стоблцами
  X = iris.data[:, :2]

Если набрать print('X = ',X) то на экран выведется матрица 2 стоблца 150 строк

X =[[ 5.1  3.5]
 [ 4.9  3. ]
 [ 4.7  3.2]
 [ 4.6  3.1]
 [ 5.   3.6]
 [ 5.4  3.9]
 [ 4.6  3.4]
 [ 5.   3.4]
 [ 4.4  2.9]
 ..........
 150 строк ]]
 
5. Пока что у нас есть матрица 150 строк на 2 столбца или же 150 точек, каждая из которых имеет порядковый номер - номер строки
  и координаты одна по горизонтали и одна повертикали. 
  Теперь нужно каждой точке сопоставить признак 1 из трёх. В данном случае это 1 из трёх цветов. Объявим переменную присвоим 
  ей строку признаков.
  y = iris.target

Если набрать print('y = ',X) на экран выведется 150 чисел каждая из них сотвесттвует одному из трёх цветов для точек

y =  [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
 
6. объявим размер шага в сетке
h = 0.02  # размер шага в сетке 
объявим цвета точек на плоскости и цвета которыми будем закрашивать плоскость.
cmap_light = ListedColormap(['#bafffc', '#ffdede','#abffbd']) #цвета площадок
cmap_bold = ListedColormap(['Blue', 'Red', 'Lime']) #цвета точек

У нас есть заданная плоскость и заданныее точки на плоскости с заданными координатами и цветами. На основании 
этих точек нужно закрасить всю плоскость чтобы куда бы мы ни тыкнули новую точку, было известно, к какому классу она будет относится. 
Для этого разобъем плоскость на маленькие квадраты размером h = 0.02 подобно тому как разбита плоскость в тетраде в клетку.
Шаг лучше всего подобрать такой, чтобы размер одной клетки совпадал с размером пикселя на экране. Можно меньше, но будет производится
много излишних вычислений. Если шаг взять больше то будут видны квадраты на плоскости.

7. далее я объявил функуию def knn(weights_):
параметр weights_ указывает правило по которому будут классифицироваться клетки на плоскости
при вызове используется равомерная весовая функция и весовая функция расстояния
отрисовываются 2 картинки
knn('uniform')#вклад в классификацию каждой точки одинаковый 
knn('distance')#Используется весовая функция расстояния

8. Далее я использю метод классификации knn который уже есть в библиотеке sklearn

    clf = neighbors.KNeighborsClassifier(n_neighbors, weights = weights_)#объявляю экземпляр класса
    clf.fit(X, y) # помещает в экземпляр класса данные
    
9. Далее нужно найти размер плоскости необходимый для построения. 
На плоскости имеются 150 точек нужно взять плоскость такого размера, чтобы все они в ней поместились.
Для этого нужно пробежаться по всем точкам и найти 4 значения:
самую минимальную и самую максимальную координату по горизонтали и вертикали,
а потом от минимальных отнять 1 а к максимальным прибавить, чтобы была рамка в которой точек нет

    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1#находим минимальное и максимальное 
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    
    разберём подробно верхние 2 строки кода
    было выше пункт 4. объявленно X = iris.data[:, :2] 
    2 стоблца по 150 строк или же координаты по горизонтали первый столбец и по вертикали второй всех 150 точек 
    
    X[:, 0] один сблобец координат всех 150 точек по горизонтали
    X[:, 1] один сблобец координат всех 150 точек по вертикали
    
    X[:, 0].min() минимальная координата по горизонтали
    X[:, 1].min() минимальная координата по вертикали
    X[:, 0].max() максимальная координата по горизонтали
    X[:, 1].max() максимальная координата по вертикали
    // +-1 надеюсь итак понятно
    далее присвоение переменным значений
  
  10. xx, yy = np.meshgrid(np.arange(x_min, x_max, h),  np.arange(y_min, y_max, h))
  разберём эту строку
  np.arange(x_min, x_max, h) 
   ф-я np.arange(начало, конец, шаг) возвращает одномерный массив равномерно распределённую величину от начала до конца с шагом
     например np.arange(0, 0.5, 0.1) вернёт [ 0.   0.1  0.2  0.3  0.4]
     например np.arange(0, 0.5, 0.2) вернёт [ 0.   0.2  0.4] 
  в данном случае np.arange(x_min, x_max, h) возвращает координаты квадратов сетки по горизонтали 
  по вертикали так же np.arange(y_min, y_max, h)
  
  далее ф-я np.meshgrid() возвращает 2 значения (2 матрицы) и присваеивает двум переменным xx yy
  
  ![meshgrid](https://user-images.githubusercontent.com/33224690/32692907-8928ef6a-c6d5-11e7-96a0-e72e952ce069.png)
  

